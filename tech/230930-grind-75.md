Grind 75
====

[Grind 75 questions](https://www.techinterviewhandbook.org/grind75)

## 1. Two Sum

[1. Two Sum](https://leetcode.com/problems/two-sum/)

1. brute force
2. using hashmap to cache the index of `complement`
   1. two loop
   2. one loop

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.HashMap;
import java.util.Map;

/**
 * <a href="https://leetcode.com/problems/two-sum/">Two Sum</a> 
 */
class TwoSum {
    private final Map<Integer, Integer> cache = new HashMap<>();
    public int[] twoSum(final int[] nums, final int target) {
        for (int i = 0; i < nums.length; i++) {
            final int residual = target - nums[i];
            if (cache.containsKey(residual)) {
                return new int[] {cache.get(residual), i};
            }
            cache.put(nums[i], i);
        }
        return new int[]{};
    }

    @Test
    void testTwoSumOne() {
        final int[] nums = new int[]{2, 7, 11, 15};
        final int target = 9;
        Assertions.assertArrayEquals(new int[]{0, 1}, twoSum(nums, target));
    }

    @Test
    void testTwoSumTwo() {
        final int[] nums = new int[]{3, 2, 4};
        final int target = 6;
        Assertions.assertArrayEquals(new int[]{1, 2}, twoSum(nums, target));
    }

    @Test
    void testTwoSumThree() {
        final int[] nums = new int[]{3, 3};
        final int target = 6;
        Assertions.assertArrayEquals(new int[]{0, 1}, twoSum(nums, target));
    }
}
```

## Best Time to Buy and Sell Stock

1. brute force
2. one loop: if current price is lower than the previous one, we reset the buy point to the current one, because it's impossible to be the sell point for previous time series data.

```java

```

## Valid Parentheses

1. use the stack data structure

```java

```

## 1235. Maximum Profit in Job Scheduling

[1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/)

```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

/**
 * <a href="https://leetcode.com/problems/maximum-profit-in-job-scheduling/">Maximum Profit in Job Scheduling</a> 
 */
class JobScheduling {
    public int jobScheduling(final int[] startTime, final int[] endTime, final int[] profit) {
        return 0;
    }

    @Test
    void testJobSchedulingOne() {
        final int[] startTime = new int[]{1, 2, 3, 3};
        final int[] endTime = new int[]{3, 4, 5, 6};
        final int[] profit = new int[]{50, 10, 40, 70};
        Assertions.assertEquals(120, jobScheduling(startTime, endTime, profit));
    }

    @Test
    void testJobSchedulingTwo() {
        final int[] startTime = new int[]{1, 2, 3, 4, 6};
        final int[] endTime = new int[]{3, 5, 10, 6, 9};
        final int[] profit = new int[]{20, 20, 100, 70, 60};
        Assertions.assertEquals(150, jobScheduling(startTime, endTime, profit));
    }

    @Test
    void testJobSchedulingThree() {
        final int[] startTime = new int[]{1, 1, 1};
        final int[] endTime = new int[]{2, 3, 4};
        final int[] profit = new int[]{5, 6, 4};
        Assertions.assertEquals(6, jobScheduling(startTime, endTime, profit));
    }
}
```

## 70. Climbing Stairs

[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)


